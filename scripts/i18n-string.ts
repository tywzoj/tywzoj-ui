import * as fs from "fs";
import { dump as yamlDump, load as yamlLoad } from "js-yaml";
import { resolve as pathResolve } from "path";

const supportedLanguages = ["en", "zh-cn"];

const defaultLanguage = "en";

const localeDir = pathResolve(__dirname, "..", "i18n");
const staticDir = pathResolve(__dirname, "..", "src", "assets", "locales");
const typeFileDir = pathResolve(__dirname, "..", "src", "locales");

const typeFileName = "strings.gen.d.ts";

interface ILocalizedString {
    name: string;
    value: string | null;
    description: string;
    raw?: string;
}

main();

function main() {
    const rawStrings = getRawStrings();
    const typeContent = generateTypes(rawStrings);

    for (const lang of supportedLanguages) {
        const localizedStrings = getLocalizedString(lang);
        const strings = convertRawToLocalizedString(rawStrings, localizedStrings, lang);
        writeLocaleFile(lang, strings);
        setLocalizedString(lang, strings);
    }

    writeTypeFiles(typeContent);
}

function generateTypes(localizedStrings: ILocalizedString[]): string {
    let content = "";
    content += '// This file is auto-generated by "yarn i18n"\n';
    content += "// Do NOT modify this file directly.\n\n";

    // Generate localized string interface, map id to value
    content += "interface ILocalizedStrings {\n";
    for (const localizedString of localizedStrings) {
        content += `/** ${localizedString.description} */\n`;
        content += `${getStringName(localizedString)}: ${JSON.stringify(localizedString.value ?? "BAD STRING")};\n`;
    }
    content += "}\n";

    return content;
}

function getStringName({ name }: ILocalizedString): string {
    if (name.startsWith("ERROR_")) {
        const errorString = name.split("_")[1];
        const idError = Number.parseInt(errorString, 10);
        return `E_${idError}`;
    } else {
        return `$${name}`;
    }
}

function getLocalizedString(lang: string): ILocalizedString[] {
    const filePath = pathResolve(localeDir, `localized.${lang}.yaml`);
    if (!fs.existsSync(filePath)) {
        return [];
    }

    return yamlLoad(fs.readFileSync(filePath, "utf-8")) as ILocalizedString[];
}

function setLocalizedString(lang: string, strings: ILocalizedString[]) {
    const filePath = pathResolve(localeDir, `localized.${lang}.yaml`);
    fs.writeFileSync(filePath, yamlDump(strings).replace(/\n-/g, "\n\n-"));
}

function getRawStrings(): ILocalizedString[] {
    const rawStringFilePath = pathResolve(localeDir, "raw.yaml");
    const raw = yamlLoad(fs.readFileSync(rawStringFilePath, "utf-8")) as ILocalizedString[];

    // Rewrite the file to standard YAML format
    fs.writeFileSync(rawStringFilePath, yamlDump(raw).replace(/\n-/g, "\n\n-"));

    return raw;
}

function writeTypeFiles(typeContent: string) {
    fs.mkdirSync(typeFileDir, { recursive: true });
    const typePath = pathResolve(typeFileDir, typeFileName);
    fs.writeFileSync(typePath, typeContent);
}

function writeLocaleFile(lang: string, strings: ILocalizedString[]) {
    fs.mkdirSync(staticDir, { recursive: true });
    const filePath = pathResolve(staticDir, `strings.${lang}.js`);

    let js = `export default{`;
    for (const item of strings) {
        js += `${getStringName(item)}:${JSON.stringify(item.value ?? item.raw ?? "BAD STRING")},`;
    }
    js += `}`;

    fs.writeFileSync(filePath, js);
}

function convertRawToLocalizedString(
    rawStrings: ILocalizedString[],
    localizedString: ILocalizedString[],
    lang: string,
): ILocalizedString[] {
    return rawStrings.map((rawString) => {
        if (lang === defaultLanguage) {
            return {
                name: rawString.name,
                value: rawString.value,
                description: rawString.description,
                raw: rawString.value ?? "BAD STRING",
            };
        }

        const localized = localizedString.find((ls) => ls.name === rawString.name);
        return {
            name: rawString.name,
            value: localized && localized.raw === rawString.value ? localized.value : null,
            description: rawString.description,
            raw: rawString.value ?? "BAD STRING",
        };
    });
}
